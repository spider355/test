-- =============================================================================
--  HERMOD, THE SPIRIT OF WAR — Boss Script  [v2.0]
--  MemoryError RS3 Client | Lua
--  Modelled on Sonson's Rasial architecture
--
--  FEATURES:
--    • Sanson-style tabbed config GUI (General / War's Retreat / Player Manager /
--      Loot / Debug)
--    • Full War's Retreat loop: bank → altar → adrenaline crystal → portal
--    • State machine: WARS_RETREAT → ENTERING → FIGHTING → KILLING_MINIONS →
--      LOOTING → RETURNING → repeat
--    • Prayer flicker (Soul Split default, Deflect Melee on phantoms)
--    • Health / prayer management with configurable thresholds
--    • GP tracking, kill/hr stats, live status overlay
--
--  FILE STRUCTURE (place in Lua_Scripts/):
--    Lua_Scripts/
--    ├── core/
--    │   ├── timer.lua
--    │   ├── player_manager.lua
--    │   ├── prayer_flicker.lua
--    │   ├── wars_retreat.lua
--    │   └── gui_lib.lua
--    ├── hermod/
--    │   ├── main.lua          ← this file
--    │   └── gui.lua
--    ├── api.lua               (generated by MemoryError)
--    └── usertypes.lua         (generated by MemoryError)
--
--  SETUP:
--    1. Verify NPC IDs in CONSTANTS section with MemoryError's NPC scanner
--    2. Verify item IDs with MemoryError's Ground Item overlay
--    3. Attune a War's Retreat portal to Hermod
--    4. Run script — config GUI will open before anything starts
--    5. Set your preferences and click Start
-- =============================================================================

-- ── MEMORYERROR API IMPORTS ──────────────────────────────────────────────────
local API       = require("api")
local usertypes = require("usertypes")

-- ── LIBRARY IMPORTS ──────────────────────────────────────────────────────────
local Timer         = require("core/timer")
local PlayerManager = require("core/player_manager")
local PrayerFlicker = require("core/prayer_flicker")
local WarsRetreat   = require("core/wars_retreat")
local GuiModule     = require("hermod/gui")

-- ── CONSTANTS — VERIFY IN-GAME BEFORE FIRST RUN ─────────────────────────────
local NPC_ID = {
    HERMOD           = 30163,  -- Hermod, the Spirit of War
    ARMOURED_PHANTOM = 30164,  -- Armoured phantom (minion)
}

-- Item IDs — enable MemoryError Ground Item overlay to verify these.
-- The Hermodic plate is 1/10 and is the primary farming target.
local ALL_LOOT = {
    -- Unique / high-value
    { id = 49394, name = "Hermodic plate",         key = "lootHermodicPlate", gpValue = 500000 },
    { id = 49395, name = "Hermod's armour spike",  key = "lootArmourSpike",   gpValue = 200000 },
    -- Regular drops
    { id = 536,   name = "Big bones",              key = "lootBigBones",      gpValue = 300    },
    { id = 995,   name = "Coins",                  key = "lootCoins",         gpValue = 1      },
    -- *** Add more lines here as you discover drops in-game ***
    -- Template: { id = 0000, name = "Item name", key = "lootOtherDrops", gpValue = 0 },
}

-- Boss area coordinates — stand inside arena and read from MemoryError overlay
local BOSS_ROOM_COORDS = { x = 864, y = 1760, range = 35 }

-- Timing constants
local LOOP_SLEEP_MS   = 150
local LOOP_SLEEP_VAR  = 50
local LOOT_WINDOW_SEC = 12
local RETURN_DELAY_MS = 2000

-- ── STATE MACHINE ────────────────────────────────────────────────────────────
local States = {
    IDLE              = "IDLE",
    WARS_RETREAT      = "WAR'S RETREAT",
    ENTERING_INSTANCE = "ENTERING INSTANCE",
    FIGHTING_BOSS     = "FIGHTING BOSS",
    KILLING_MINIONS   = "KILLING MINIONS",
    LOOTING           = "LOOTING",
    RETURNING         = "RETURNING",
}

-- ── RUNTIME STATE ────────────────────────────────────────────────────────────
local currentState  = States.IDLE
local lootStartTime = 0
local returnStartT  = 0
local killCount     = 0
local sessionStart  = os.time()
local estimatedGP   = 0
local lastTargetId  = 0

-- ── HELPERS ──────────────────────────────────────────────────────────────────

local CFG  -- set after GUI confirms start

local function log(msg, module)
    if module == "timer"  and (not CFG or not CFG.debugTimer)  then return end
    if module == "player" and (not CFG or not CFG.debugPlayer) then return end
    if module == "prayer" and (not CFG or not CFG.debugPrayer) then return end
    if module == "wars"   and (not CFG or not CFG.debugWars)   then return end
    if module == "main"   and CFG and not CFG.debugMain        then return end
    API.logMessage(msg)
end

local function logMain(msg)  log(msg, nil)    end
local function logDebug(msg) log(msg, "main") end

local function commify(n)
    local s = tostring(math.floor(n or 0))
    local r = s:reverse():gsub("(%d%d%d)", "%1,"):reverse()
    return r:gsub("^,", "")
end

local function getNPCs(id, range)
    return API.GetAllObjArrayInteract({id}, 1, range or 30) or {}
end

local function hermodExists()   return #getNPCs(NPC_ID.HERMOD,           30) > 0 end
local function getPhantoms()    return getNPCs(NPC_ID.ARMOURED_PHANTOM,  30)     end
local function phantomsAlive()  return #getPhantoms() > 0                        end
local function phantomCount()   return #getPhantoms()                            end

local function attackNPC(npcId, range)
    return API.DoAction_NPC1(0x10, API.OFF_ACT_NpcT_route, {npcId}, range or 30)
end

local function buildLootIds()
    local ids = {}
    for _, entry in ipairs(ALL_LOOT) do
        local enabled = not CFG or CFG[entry.key]
            or (entry.key == "lootOtherDrops" and CFG.lootOtherDrops)
        if enabled then table.insert(ids, entry.id) end
    end
    return ids
end

local function lootNearbyItems()
    for _, itemId in ipairs(buildLootIds()) do
        local ground = API.GetAllObjArrayInteract({itemId}, 4, 8)
        if ground and #ground > 0 then
            logMain(string.format("Looting item ID %d", itemId))
            API.DoAction_Object1(0x5, API.OFF_ACT_GeneralObject_route0, {itemId}, 8)
            API.RandomSleep2(400, 80, 80)
            if CFG and CFG.trackGp then
                for _, entry in ipairs(ALL_LOOT) do
                    if entry.id == itemId then
                        estimatedGP = estimatedGP + (entry.gpValue or 0)
                    end
                end
            end
        end
    end
end

-- ── GUI — CONFIG WINDOW ───────────────────────────────────────────────────────
local gui = GuiModule.new()

logMain("Waiting for GUI start...")
while API.Read_LoopyLoop() and not gui:isStarted() do
    gui:drawConfig()
    API.RandomSleep2(50, 10, 10)
end

if not API.Read_LoopyLoop() then
    logMain("Script cancelled.")
    return
end

CFG = gui:getConfig()
logMain("Config confirmed. Starting Hermod script...")

-- ── WAR'S RETREAT MODULE ──────────────────────────────────────────────────────
local warsRetreat
if CFG.useWarsRetreat then
    warsRetreat = WarsRetreat.new({
        bankPin         = CFG.bankPin,
        summonConjures  = CFG.summonConjures,
        useAdrenCrystal = CFG.useAdrenCrystal,
        prayAtAltar     = CFG.prayAtAltar,
        surgeDiveChance = CFG.surgeDiveChance,
        minHealth       = CFG.minHpToEnter,
        minPrayer       = CFG.minPrayerToEnter,
        bossPortalName  = "Hermod, the Spirit of War",
        debugMode       = CFG.debugWars,
    })
    logMain("War's Retreat module ready.")
end

-- ── PRAYER FLICKER ────────────────────────────────────────────────────────────
local SOUL_SPLIT    = CFG.useCurses and PrayerFlicker.CURSES.SOUL_SPLIT    or PrayerFlicker.PRAYERS.RAPID_HEAL
local DEFLECT_MELEE = CFG.useCurses and PrayerFlicker.CURSES.DEFLECT_MELEE or PrayerFlicker.PRAYERS.PROTECT_FROM_MELEE

local prayerFlicker = PrayerFlicker.new({
    defaultPrayer = SOUL_SPLIT,
    threats = {
        {
            name      = "Armoured Phantom melee",
            type      = "Conditional",
            priority  = 10,
            prayer    = DEFLECT_MELEE,
            condition = function() return phantomsAlive() end,
            duration  = 2,
            delay     = 0,
        },
    },
    debugMode = CFG.debugPrayer,
})

-- ── PLAYER MANAGER ────────────────────────────────────────────────────────────
local playerManager = PlayerManager.new({
    health = {
        normal   = { type = "percent", value = CFG.hpThresholdPct },
        critical = { type = "percent", value = CFG.hpCriticalPct  },
        special  = { type = "percent", value = CFG.hpSpecialPct   },
    },
    prayer = {
        normal   = { type = "percent", value = CFG.prayerThresholdPct },
        critical = { type = "percent", value = CFG.prayerCriticalPct  },
    },
    locations = {
        { name = "Hermod's Arena", coords = BOSS_ROOM_COORDS },
    },
    debugMode = CFG.debugPlayer,
})

-- ── TIMERS ────────────────────────────────────────────────────────────────────
local attackBossTimer = Timer.new({
    name     = "Attack Hermod",
    cooldown = 3,
    useTicks = true,
    condition = function()
        return currentState == States.FIGHTING_BOSS
            and hermodExists()
            and not phantomsAlive()
            and not API.PlayerIsMovin2()
    end,
    action = function()
        if lastTargetId ~= NPC_ID.HERMOD then
            logDebug("Re-targeting Hermod")
            lastTargetId = NPC_ID.HERMOD
        end
        return attackNPC(NPC_ID.HERMOD)
    end,
    debugMode = CFG.debugTimer,
})

local attackPhantomTimer = Timer.new({
    name     = "Attack Phantoms",
    cooldown = 2,
    useTicks = true,
    condition = function()
        return currentState == States.KILLING_MINIONS
            and phantomsAlive()
            and not API.PlayerIsMovin2()
    end,
    action = function()
        local ph = getPhantoms()
        if #ph > 0 then
            if lastTargetId ~= NPC_ID.ARMOURED_PHANTOM then
                logDebug(string.format("Targeting Armoured Phantom (%d alive)", #ph))
                lastTargetId = NPC_ID.ARMOURED_PHANTOM
            end
            return attackNPC(NPC_ID.ARMOURED_PHANTOM)
        end
        return false
    end,
    debugMode = CFG.debugTimer,
})

local lootTimer = Timer.new({
    name     = "Loot drops",
    cooldown = 700,
    useTicks = false,
    condition = function() return currentState == States.LOOTING end,
    action    = function() lootNearbyItems(); return true end,
    debugMode = CFG.debugTimer,
})

-- ── STATE TRANSITIONS ─────────────────────────────────────────────────────────
local function updateState()
    local hp             = (API.GetHP and API.GetHP()) or 100
    local hermodPresent  = hermodExists()
    local minionsPresent = phantomsAlive()

    -- IDLE ────────────────────────────────────────────────────────────────────
    if currentState == States.IDLE then
        if CFG.useWarsRetreat then
            logMain("Starting War's Retreat prep loop...")
            currentState = States.WARS_RETREAT
        else
            logMain("Manual mode — waiting inside instance...")
            currentState = States.ENTERING_INSTANCE
        end
        return
    end

    -- WARS_RETREAT ────────────────────────────────────────────────────────────
    if currentState == States.WARS_RETREAT then
        if not warsRetreat then
            currentState = States.ENTERING_INSTANCE
            return
        end
        local done = warsRetreat:run()
        if done then
            logMain("Preparation complete — entering portal...")
            currentState = States.ENTERING_INSTANCE
        end
        return
    end

    -- ENTERING_INSTANCE ───────────────────────────────────────────────────────
    if currentState == States.ENTERING_INSTANCE then
        if CFG.waitForFullHp and hp < 95 then return end
        if hermodPresent then
            logMain("Hermod detected — fight starting!")
            lastTargetId = NPC_ID.HERMOD
            currentState = States.FIGHTING_BOSS
        end
        return
    end

    -- FIGHTING_BOSS ───────────────────────────────────────────────────────────
    if currentState == States.FIGHTING_BOSS then
        if not hermodPresent then
            killCount     = killCount + 1
            lootStartTime = os.time()
            logMain(string.format("Kill #%d! Looting...", killCount))
            currentState = States.LOOTING
            return
        end
        if minionsPresent then
            logMain(string.format("Phantoms spawned (%d)! Switching target.", phantomCount()))
            lastTargetId = NPC_ID.ARMOURED_PHANTOM
            currentState = States.KILLING_MINIONS
        end
        return
    end

    -- KILLING_MINIONS ─────────────────────────────────────────────────────────
    if currentState == States.KILLING_MINIONS then
        if not minionsPresent then
            if hermodPresent then
                logMain("Phantoms dead — back to Hermod!")
                lastTargetId = NPC_ID.HERMOD
                currentState = States.FIGHTING_BOSS
            else
                killCount     = killCount + 1
                lootStartTime = os.time()
                logMain("Phantoms dead and Hermod also gone — looting")
                currentState = States.LOOTING
            end
        end
        return
    end

    -- LOOTING ─────────────────────────────────────────────────────────────────
    if currentState == States.LOOTING then
        if os.time() - lootStartTime >= LOOT_WINDOW_SEC then
            lootStartTime = 0
            if CFG.useWarsRetreat then
                returnStartT = os.clock() * 1000
                currentState = States.RETURNING
            else
                currentState = States.ENTERING_INSTANCE
            end
            logMain("Loot window closed.")
        end
        return
    end

    -- RETURNING ───────────────────────────────────────────────────────────────
    if currentState == States.RETURNING then
        if (os.clock() * 1000) - returnStartT >= RETURN_DELAY_MS then
            logMain("Teleporting to War's Retreat...")
            -- War's Retreat Teleport spell via spellbook interface
            -- Interface 1465, component 17 is the typical War's Retreat teleport entry.
            -- If this does not work, check the MemoryError interface inspector for the
            -- correct IDs and update the call below.
            API.DoAction_Interface(0xffffffff, 0xffffffff, 0, 1465, 17, -1,
                API.OFF_ACT_GeneralInterface_route)
            API.RandomSleep2(2500, 300, 300)
            currentState = States.WARS_RETREAT
        end
        return
    end
end

-- ── STATS BUILDER ─────────────────────────────────────────────────────────────
local function buildStats()
    return {
        state        = currentState,
        killCount    = killCount,
        sessionSecs  = os.time() - sessionStart,
        estimatedGP  = estimatedGP,
        hp           = (API.GetHP and API.GetHP()) or 0,
        prayer       = (API.GetPrayPrecent and API.GetPrayPrecent()) or 0,
        hermodAlive  = hermodExists(),
        phantomCount = phantomCount(),
        lastTarget   = (lastTargetId == NPC_ID.HERMOD and "Hermod")
                    or (lastTargetId == NPC_ID.ARMOURED_PHANTOM and "Phantom")
                    or "—",
        atWars       = currentState == States.WARS_RETREAT,
    }
end

-- ── MAIN LOOP ─────────────────────────────────────────────────────────────────
logMain(string.format("HERMOD v2.0 | Mode: %s | Curses: %s",
    CFG.useWarsRetreat and "Wars Retreat loop" or "Manual",
    tostring(CFG.useCurses)))

currentState = States.IDLE

while API.Read_LoopyLoop() do

    -- 1. Health / prayer restoration (always)
    playerManager:update()
    playerManager:manageHealth()
    playerManager:managePrayer()

    -- 2. Prayer flicker
    local inCombat = currentState == States.FIGHTING_BOSS
                  or currentState == States.KILLING_MINIONS
    if inCombat then
        prayerFlicker:update()
    else
        prayerFlicker:deactivatePrayer()
    end

    -- 3. State machine tick
    updateState()

    -- 4. Timed actions
    if     currentState == States.FIGHTING_BOSS    then attackBossTimer:execute()
    elseif currentState == States.KILLING_MINIONS  then attackPhantomTimer:execute()
    elseif currentState == States.LOOTING          then lootTimer:execute()
    end

    -- 5. Status overlay
    gui:drawStatus(buildStats())

    -- 6. Sleep
    API.RandomSleep2(LOOP_SLEEP_MS, LOOP_SLEEP_VAR, LOOP_SLEEP_VAR)
end

-- ── CLEANUP ───────────────────────────────────────────────────────────────────
prayerFlicker:deactivatePrayer()
logMain(string.format("Stopped. Kills: %d | Est. GP: %s | Runtime: %ds",
    killCount, commify(estimatedGP), os.time() - sessionStart))
